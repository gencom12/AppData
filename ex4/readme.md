# Notes

1. ColumnTransformer (library)
```py
from sklearn.compose import ColumnTransfer
from sklearn.preprocessing import OneHotEncoder

ct = ColumnTransformer(tranformers=[("enocoder",OneHotEncoder(),[c1,c2,c3])],remainder='passthrough')
```

2. Correlation heatmap (function)

```py
import mathplotlib.pyplot as plt

def corr_heatmap(df):
  corr = df.corr()
  plt.figure(figsize=(w,h))
  caxes = plt.matshow(corr,fignum=1)
  plt.xticks(range(len(corr.columns)),corr.columns,rotation=90)
  plt.yticks(range(len(corr.columns)),corr.columns)
  plt.colorbar(caxes)
  plt.show()
```
3. LabelEncoder vs OneHotEncoder
```
Label Encoder can be used for ordinal data only ( operations are <,>,=,!=)

But it can't be used for nominal data because its only operaion is =,!=

So we should use onehotencoder for nominal data where 
there is no relationship between the categorical data
```

4. Remove Correlated columns 
```
As it increases the computation and complexity of the dataset
```  

5. Add columns after encoding
```py
col = [0,1,3,4]
transformer = [("hot",OneHotEncoder(),col)]
ct = ColumnTransformer(transformers=transformer,remainder="passthrough")
X_ct = pd.DataFrame(ct.fit_transform(X))


enc_col_names = ct.named_transformers_["hot"].get_feature_names_out()
col_names = list(enc_col_names) + list(X.columns.drop(X.columns[col]))
X_ct.columns = col_names
```

6. Imblearn is a library which is used to handle imbalanced dataset
```py
from imblearn.over_sampling import SMOTE
smote = SMOTE()
X_sm,y_sm = smote.fit_resample(X,y)
```
7. How does SMOTE work?
```
For each minority class sample, it chooses k nearest neighbors in the feature space.

A synthetic sample is then generated by picking one of the k nearest neighbors and taking a random linear combination of the feature values of the sample and the chosen nearest neighbor.

This process is repeated for all the minority class samples until the desired class distribution is reached.
```